<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.8.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo.ico">
	<link rel="shortcut icon" href="/img/logo.ico">
	
			    <title>
    HuiXinsNote
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    <meta name="keywords" content="PoetryScience">
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_dark.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">PoetryScience</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">HOME</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">CATEGORIES</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/iRobots/">iRobots</a></li><li><a class="category-link" href="/categories/写作/">写作</a></li><li><a class="category-link" href="/categories/学习笔记/">学习笔记</a></li><li><a class="category-link" href="/categories/技术笔记/">技术笔记</a></li><li><a class="category-link" href="/categories/文献阅读/">文献阅读</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="ABOUT">
		                ABOUT
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="FRIENDS">
		                FRIENDS
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="GALLERY">
		                GALLERY
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="TAGS">
		                TAGS
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/donghuixin" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="weibo" href="https://weibo.com/u/5315885243?refer_flag=1001030102_&is_hot=1" target="_blank" rel="noopener">
                            <i class="icon fa fa-weibo"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="instagram" href="https://instagram.com/huixindx" target="_blank" rel="noopener">
                            <i class="icon fa fa-instagram"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(http://image.qianye88.com/pic/344393bfcf942c2e2072929bec51e2f6);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>程序员面试问题记录【不定期更新】</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h1 id="面试常考编程"><a href="#面试常考编程" class="headerlink" title="面试常考编程"></a>面试常考编程</h1><h2 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h2><pre><code>  invert a binary tree.
      4
     /   \
    2     7
   / \   / \
  1   3 6   9 

  to
        4
     /   \
    7     2
   / \   / \
  9   6 3   1
</code></pre><h3 id="递归解决方法："><a href="#递归解决方法：" class="headerlink" title="递归解决方法："></a>递归解决方法：</h3><p>  递归算法：</p>
<ul>
<li>1、交换根节点的左右子树。</li>
<li><p>2、对左右子树分别执行递归反转 。<br>而第 1 步又是一个反转二叉树的问题，所以就可以用递归来处理了。然后再考虑好递归的结束条件，这道题就可以解决了。<br> 代码：</p>
<p>   TreeNode<em> invertTree(TreeNode</em> root) {</p>
<pre><code>if(root==NULL)
        return NULL;
    TreeNode * ptmpNode = root-&gt;left;
    root-&gt;left = invertTree(root-&gt;right);
    root-&gt;right = invertTree(ptmpNode);
    return root;
}
</code></pre><h3 id="非递归解决方法-（层次遍历）"><a href="#非递归解决方法-（层次遍历）" class="headerlink" title="非递归解决方法 （层次遍历）"></a>非递归解决方法 （层次遍历）</h3></li>
</ul>
<p>非递归算法：</p>
<p>1、交换根节点的左右子节点</p>
<p>2、交换第二层每个节点的左右子节点</p>
<p>….</p>
<p>这个与二叉树层次遍历类似，代码如下：</p>
<pre><code>  TreeNode* invertTree2(TreeNode* root) {
          queue&lt;TreeNode*&gt; tree_queue;
          if (root == NULL)
              return root;
          tree_queue.push(root);
          while(tree_queue.size() &gt; 0){
              TreeNode * pNode = tree_queue.front();
              tree_queue.pop();
              TreeNode * pLeft = pNode-&gt;left;
              pNode-&gt;left = pNode-&gt;right;
              pNode-&gt;right = pLeft;
              if (pNode-&gt;left)
                  tree_queue.push(pNode-&gt;left);
              if (pNode-&gt;right)
                  tree_queue.push(pNode-&gt;right);
          }
          return root;
      }
</code></pre><h1 id="算法类问题"><a href="#算法类问题" class="headerlink" title="算法类问题"></a>算法类问题</h1><h2 id="海量日志数据，提取出某日访问百度次数最多的那个IP"><a href="#海量日志数据，提取出某日访问百度次数最多的那个IP" class="headerlink" title="海量日志数据，提取出某日访问百度次数最多的那个IP"></a>海量日志数据，提取出某日访问百度次数最多的那个IP</h2><p>首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个$2^32$个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。<br>或者如下阐述（雪域之鹰）：<br><br><strong>算法思想：分而治之+Hash</strong></p>
<ul>
<li>1.IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理； </li>
<li>2.可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址； </li>
<li>3.对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址；</li>
<li>4.可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；<br><a href="https://blog.csdn.net/v_july_v/article/details/6279498" target="_blank" rel="noopener">原文：</a><h2 id="怎么在海量数据中找出重复次数最多的一个？"><a href="#怎么在海量数据中找出重复次数最多的一个？" class="headerlink" title="怎么在海量数据中找出重复次数最多的一个？"></a>怎么在海量数据中找出重复次数最多的一个？</h2>方案1：先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）<h1 id="网络通信类问题"><a href="#网络通信类问题" class="headerlink" title="网络通信类问题"></a>网络通信类问题</h1><h2 id="socket是什么，功能，结构，用途…"><a href="#socket是什么，功能，结构，用途…" class="headerlink" title="socket是什么，功能，结构，用途…"></a>socket是什么，功能，结构，用途…</h2>网络资料，原博文地址 <a href="https://www.cnblogs.com/dolphinX/p/3460545.html" target="_blank" rel="noopener">-&gt;Link</a><br><br>什么是socket呢？我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。<center><br><img src="https://res.cloudinary.com/donghuixin/image/upload/v1555243459/Coding/socket.jpg" alt="socket"><br></center><br>socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种”打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。<br>### socket通信流程<br>socket是”打开—读/写—关闭”模式的实现，以使用TCP协议通讯的socket为例，其交互流程大概是这样子的<br><center><br><img src="https://res.cloudinary.com/donghuixin/image/upload/v1555243459/Coding/socket2.png" alt="communicate"><br></center></li>
<li>服务器根据地址类型（ipv4,ipv6）、socket类型、协议创建socket</li>
<li>服务器为socket绑定ip地址和端口号</li>
<li>服务器socket监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的socket并没有被打开</li>
<li>客户端创建socket</li>
<li>客户端打开socket，根据服务器ip地址和端口号试图连接服务器socket</li>
<li>服务器socket接收到客户端socket请求，被动打开，开始接收客户端请求，直到客户端返回连接信息。这时候socket进入阻塞状态，所谓阻塞即accept()方法一直到客户端返回连接信息后才返回，开始接收下一个客户端谅解请求</li>
<li>客户端连接成功，向服务器发送连接状态信息</li>
<li>服务器accept方法返回，连接成功</li>
<li>客户端向socket写入信息</li>
<li>服务器读取信息</li>
<li>客户端关闭</li>
<li>服务器端关闭<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3>在TCP/IP协议中，TCP协议通过三次握手建立一个可靠的连接<center><br><img src="https://res.cloudinary.com/donghuixin/image/upload/v1555243461/Coding/TCPIP.jpg" alt="TCP/IP"><br></center></li>
<li>第一次握手：客户端尝试连接服务器，向服务器发送syn包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入SYN_SEND状态等待服务器确认</li>
<li>第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态</li>
<li><p>第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手<br><strong>定睛一看，服务器socket与客户端socket建立连接的部分其实就是大名鼎鼎的三次握手</strong><br><center><br><img src="https://res.cloudinary.com/donghuixin/image/upload/v1555243458/Coding/socket3.png" alt="socket3"><br></center></p>
<h2 id="QQ-微信使用的是UDP还是TCP"><a href="#QQ-微信使用的是UDP还是TCP" class="headerlink" title="QQ/微信使用的是UDP还是TCP"></a>QQ/微信使用的是UDP还是TCP</h2><h3 id="QQ是UDP为主，TCP为辅"><a href="#QQ是UDP为主，TCP为辅" class="headerlink" title="QQ是UDP为主，TCP为辅"></a>QQ是UDP为主，TCP为辅</h3><p>  QQ是基于OICQ协议，平常聊天用UDP，传输大数据时用TCP。<br> 由于QQ的服务器设计容量是海量级的应用，一台服务器要同时容纳十几万的并发连接，因此服务器端只有采用UDP协议与客户端进行通讯才能保证这种超大规模的服务。<br><br>　　QQ客户端之间的消息传送也采用了UDP模式，这不同于国外的ICQ在客户端之间采用TCP进行通讯的模式。因为国内的网络环境非常复杂，而且很多用户采用的方式是通过代理服务器共享一条线路上网的方式，在这些复杂的情况下，客户端之间能彼此建立起来TCP连接的概率较小，严重影响传送信息的效率。而UDP包能够穿透大部分的代理服务器，因此我们在开发QQ的时候选择了UDP作为客户之间的主要通信协议，因此网友会觉得用QQ传送信息要比ICQ及其它采用TCP协议的ICQ类软件快。<br><br>　　当然，<strong>UDP协议优点突出，缺点也很明显：UDP包的传送是不可靠的传输，它不象TCP一样有包重传等机制，因此采用UDP协议的信息在传送过程中很容易丢失，这样就需要辅助的算法实现包重传机制以保证信息不会丢失，</strong>而QQ服务器的负荷非常重，因此在QQ 99b 0425之前我们只是在客户端到客户端之间传送消息时采用了这个辅助的机制，当消息在客户间直接传送无法到达时就需要通过服务器来中转，由于服务器端在老版本的时候迫于负荷过重的压力没有对主动发往客户端的信息进行传输控制，因此在老版本的时候容易造成通过服务器中转的信息丢失的现象。在QQ99c 0725之后我们单独设立出了几台专用的服务器采用包重传机制来中转消息（仅限于QQc之间传递的消息），确保通过服务器转发。</p>
<h3 id="微信聊天使用的是TCP-视频（UDP）"><a href="#微信聊天使用的是TCP-视频（UDP）" class="headerlink" title="微信聊天使用的是TCP,视频（UDP）"></a>微信聊天使用的是TCP,视频（UDP）</h3><p>微信登陆后建立TCP长连接：心跳包约300s一次（Google原生是1680s）<br><br>微信的通信协议采用基于TCP的 HTTP协议,在连接方式上采用长连接和短连接结合的 方式。<br></p>
<h4 id="微信的通信过程"><a href="#微信的通信过程" class="headerlink" title="微信的通信过程"></a>微信的通信过程</h4><p>微信在登录的时候,采用TCP短连接的方式进行认证。<br><br>微信客户端首先发起一个TCP连接到鉴权服务器, 将加密后的用户名及密码用HTTP协议提交给服务器, 服务器返回加密后的认证结果,鉴权完毕后连接断开。一次鉴权过程的数据流量在1K字节左右。在鉴权成功后,微信会向业务服务器重新发起一个TCP连接,该连接会一直保持,并采用心跳包来定时检测连接的有效性(下文中将此连接称为业务链路),微信 客户端主动发送的消息通过此连接传输给服务器,服务器通知客户端的消息也通过此连接发送到客户端。</p>
</li>
<li><p>业务链路连接成功后,微信客户端首先通过此连接 查询是否有新的更新内容<br>(包括新消息、新好友添加记录、新朋友圈信息等),之后进入主界面等待用户进行下一步操作。整个登录过程以及更新操作产生的流量大约为3K字节。登录后在微信客户端的各个页签之间切换不产生任何数据交互。</p>
</li>
</ul>
<p>后续所有涉及到通信的功能全部在业务链路上进行数据交互,如文字信息的收发、图片的收发、语音信息的收发等.</p>
<h4 id="微信的心跳和通知机制"><a href="#微信的心跳和通知机制" class="headerlink" title="微信的心跳和通知机制"></a>微信的心跳和通知机制</h4><p>根据TCP协议的特征可以知道,在断开一个TCP连接时,需要进行四次握手,首先由主动断开的一方发送一个FIN消息给另一方,另一方回复ACK消息,然后由另一方发起同样FIN/ACK交互流程后,整个连接断开。TCP连接在没有数据收发的情况下,不会有任何的数据 包交互,当连接异常断线时,只有主动发数据包的一方可以检测到连接断线,因为这时可以发现对端无应答; 等待接收的一方是无法检测到的,因为主机宕机、网线断开等异常情况将导致等待方永远不会接收到FIN信息。检测TCP长连接有效性的唯一方法是由一方定时发送一个数据包(俗称心跳包),如果连接异常断线,发送方在发送的时候即可检测到,而另一方则设置一个网络 空闲计时器,当超过约定时间未收到心跳包,则认为连 接已异常断开。<br><br>心跳周期(即网络空闲定时器的超时时间)过长,则服务器端要等比较长的时间才能检测到连接断线;心跳周期过短时虽然能够很快检测到连接断线,但是消耗在心跳包上的网络资源会过大。业界对微信的最大诟病正是在于微信在非活动状态下 的过于频繁的心跳机制。<br><br>由于操作系统的不同特征,微信在iOS下以及Android操作系统下的心跳机制有着显著的区别。根据市场研究机构Strategy Analytics发布的数据表明,2012年第4季度, 在中国大陆市场出货的智能手机当中,98%采用Android和iOS两大操作平台。其中,Android智能手机占86%,iOS智能手机只占12%<br><a href="https://www.cnblogs.com/oc-bowen/p/6064642.html" target="_blank" rel="noopener">原博文地址</a></p>
<h2 id="http和https的区别-SSL是什么"><a href="#http和https的区别-SSL是什么" class="headerlink" title="http和https的区别 SSL是什么"></a>http和https的区别 SSL是什么</h2><h3 id="一、HTTP和HTTPS的基本概念"><a href="#一、HTTP和HTTPS的基本概念" class="headerlink" title="一、HTTP和HTTPS的基本概念"></a>一、HTTP和HTTPS的基本概念</h3><ul>
<li>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</li>
<li>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。<br><br>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。<h3 id="二、HTTP与HTTPS有什么区别？"><a href="#二、HTTP与HTTPS有什么区别？" class="headerlink" title="二、HTTP与HTTPS有什么区别？"></a>二、HTTP与HTTPS有什么区别？</h3>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。<br><br>HTTPS加密、加密、及验证过程，如下图所示：<br><center><br><img src="https://user-gold-cdn.xitu.io/2017/3/26/a480d891b7240325055da1e6b2f75ac3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="httpsl"><br></center><br>简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。<br><br>HTTPS和HTTP的区别主要如下：</li>
<li>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。<h3 id="三、HTTPS的工作原理"><a href="#三、HTTPS的工作原理" class="headerlink" title="三、HTTPS的工作原理"></a>三、HTTPS的工作原理</h3>我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。<br><center><br><img src="https://user-gold-cdn.xitu.io/2017/3/26/958f7437a8245ba344750428ba0102e7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="httpsprinciple"><br></center><br>[详见原博文地址]（<a href="https://juejin.im/entry/58d7635e5c497d0057fae036）" target="_blank" rel="noopener">https://juejin.im/entry/58d7635e5c497d0057fae036）</a><h3 id="Http的长连接和短连接"><a href="#Http的长连接和短连接" class="headerlink" title="Http的长连接和短连接"></a>Http的长连接和短连接</h3><h4 id="什么是长连接、短连接？"><a href="#什么是长连接、短连接？" class="headerlink" title="什么是长连接、短连接？"></a>什么是长连接、短连接？</h4>　　在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。<br><br>但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：<br><br>  Connection:keep-alive<br>　　<br>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。<br>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。<h4 id="长连接短连接操作过程"><a href="#长连接短连接操作过程" class="headerlink" title="长连接短连接操作过程"></a>长连接短连接操作过程</h4></li>
<li>短连接的操作步骤是：<br>建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接</li>
<li>长连接的操作步骤是：<br>建立连接——数据传输…（保持连接）…数据传输——关闭连接<h4 id="长连接和短连接的优点和缺点"><a href="#长连接和短连接的优点和缺点" class="headerlink" title="长连接和短连接的优点和缺点"></a>长连接和短连接的优点和缺点</h4>长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。<br><br>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。<br><br>长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。<h4 id="什么时候用长连接，短连接？"><a href="#什么时候用长连接，短连接？" class="headerlink" title="什么时候用长连接，短连接？"></a>什么时候用长连接，短连接？</h4>　　长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。 <br><br>　　而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。<h3 id="SSL是什么"><a href="#SSL是什么" class="headerlink" title="SSL是什么"></a>SSL是什么</h3>SSL 是指安全套接字层，简而言之，它是一项标准技术，可确保互联网连接安全，保护两个系统之间发送的任何敏感数据，防止网络犯罪分子读取和修改任何传输信息，包括个人资料。两个系统可能是指服务器和客户端（例如，浏览器和购物网站），或两个服务器之间（例如，含个人身份信息或工资单信息的应用程序）。<br><br>此举可确保在用户和站点之间，或两个系统之间传输的数据无法被读取。它使用加密算法打乱传输中的数据，防止数据通过连接传输时被黑客读取。这里所说的数据是指任何敏感或个人信息，例如信用卡号和其他财务信息、个人姓名和住址等。<br><br>TLS（传输层安全）是更为安全的升级版 SSL。由于 SSL 这一术语更为常用，因此我们仍然将我们的安全证书称作 SSL。但当您从赛门铁克购买 SSL 时，您真正购买的是最新的 TLS 证书，有 ECC、RSA 或 DSA 三种加密方式可以选择。<br><br>如果某个网站受 SSL 证书保护，其相应的 URL 中会显示 HTTPS（超文本传输安全协议）。单击浏览器地址栏的挂锁图标，即可查看证书详细信息，包括颁发机构和网站所有者的公司名称<h1 id="计算机操作系统类问题"><a href="#计算机操作系统类问题" class="headerlink" title="计算机操作系统类问题"></a>计算机操作系统类问题</h1><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><h3 id="内存泄漏的概念"><a href="#内存泄漏的概念" class="headerlink" title="内存泄漏的概念"></a>内存泄漏的概念</h3>在计算机科学中，内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。<br>内存泄漏通常情况下只能由获得程序源代码的程序员才能分析出来。<br><strong>对于C和C++这种没有Garbage Collection 的语言(现代语言大多含有垃圾回收机制)来讲，我们主要关注两种类型的内存泄漏：</strong></li>
<li>堆内存泄漏（Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak. </li>
<li>系统资源泄露（Resource Leak）.主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。  <h3 id="内存泄漏的后果"><a href="#内存泄漏的后果" class="headerlink" title="内存泄漏的后果"></a>内存泄漏的后果</h3>内存泄漏会因为减少可用内存的数量从而降低计算机的性能。最终，在最糟糕的情况下，过多的可用内存被分配掉导致全部或部分设备停止正常工作，或者应用程序崩溃。<br><br>内存泄漏带来的后果可能是不严重的，有时甚至能够被常规的手段检测出来。在现代操作系统中，一个应用程序使用的常规内存在程序终止时被释放。这表示一个短暂运行的应用程序中的内存泄漏不会导致严重后果。<br>在以下情况，内存泄漏导致较严重的后果：</li>
<li>程序运行后置之不理，并且随着时间的流逝消耗越来越多的内存（比如服务器上的后台任务，尤其是嵌入式系统中的后台任务，这些任务可能被运行后很多年内都置之不理）；</li>
<li>新的内存被频繁地分配，比如当显示计算机游戏或动画视频画面时；</li>
<li>程序能够请求即使在程序终止之后也不会被释放的内存（比如共享内存）；</li>
<li>泄漏在操作系统内部发生；</li>
<li>泄漏在系统关键驱动中发生；</li>
<li>内存非常有限，比如在嵌入式系统或便携设备中；</li>
<li>当运行于一个程序终止时内存并不自动释放内存的操作系统（比如AmigaOS）之上时。</li>
</ul>
<h1 id="测试行业类问题"><a href="#测试行业类问题" class="headerlink" title="测试行业类问题"></a>测试行业类问题</h1><h2 id="如何理解软件测试-软件测试的概念"><a href="#如何理解软件测试-软件测试的概念" class="headerlink" title="如何理解软件测试(软件测试的概念)"></a>如何理解软件测试(软件测试的概念)</h2><p>软件测试是使用人工或自动手段，来运行或测试某个系统的过程。其目的在于检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别。</p>
<ul>
<li>是为了发现错误而执行程序的过程。</li>
<li>应关心程序的效率和鲁棒性等因素。</li>
<li>检验软件是否满足规定的需求。</li>
<li>弄清预期与实际结果之间的差别。<h2 id="软件测试内容包括"><a href="#软件测试内容包括" class="headerlink" title="软件测试内容包括"></a>软件测试内容包括</h2></li>
<li>制订测试计划</li>
<li>设计测试用例</li>
<li>实施测试</li>
<li>提交缺陷报告</li>
<li>测试总结 <h2 id="软件质量标准（3A）"><a href="#软件质量标准（3A）" class="headerlink" title="软件质量标准（3A）"></a>软件质量标准（3A）</h2></li>
<li><strong>Accountability (可说明性)</strong> – 用户可以基于产品或服务的描述和定义进行使用. (例如: 市场需求说明书, 功能设计说明书.)</li>
<li><strong>Availability (有效性)</strong> – 产品或服务对于99.999% 客户总是有效的   (例如: 性能测试和恢复测试)</li>
<li><p><strong>Accessibility (易用性)</strong> – 对于用户, 产品或服务非常容易使用并且一定是非常有用的功能 . (例如: 确认测试和用户可用性测试)   </p>
<h2 id="软件缺陷（Bug）是什么"><a href="#软件缺陷（Bug）是什么" class="headerlink" title="软件缺陷（Bug）是什么?"></a>软件缺陷（Bug）是什么?</h2><p>任何程序、系统中的问题，和产品设计书的不一致性，不能满足用户的需求.包括：</p>
<p>  缺点（defect）               偏差 （variance）<br>  谬误（fault）                  失败 （failure）<br>  问题（problem）            矛盾（inconsistency）<br>  错误（error ）                毛病 （incident ）<br>  异常（anomy）</p>
</li>
</ul>
<h2 id="对软件测试人员的要求是什么"><a href="#对软件测试人员的要求是什么" class="headerlink" title="对软件测试人员的要求是什么"></a>对软件测试人员的要求是什么</h2><p>测试人员通常是做为软件质量控制的一个角色，不仅仅是找bug，需要对整个软件的质量负责，性能也属于质量的一部分，因此测试人员眼中的性能应该是全面的，考虑的东西也需要全面：</p>
<ul>
<li>1、测试人员需要考虑全面的性能，包括用户、开发、管理员等各个视角的性能。</li>
<li>2、测试人员在做性能测试时除开要关注表面的现象如响应时间，也需要关注本质，比如用户看不到的服务器资料利用率，架构设计是否合理？代码是否合理等<h2 id="软件测试的一般流程"><a href="#软件测试的一般流程" class="headerlink" title="软件测试的一般流程"></a>软件测试的一般流程</h2> <center><br><img src="https://upload-images.jianshu.io/upload_images/7861428-34d90699bd5199b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="ceshi"><br></center></li>
<li>（1）业务学习：通过查看文档，手工操作系统了解系统功能</li>
<li>（2）需求分析：分析系统非功能需求，性能测试的范围，了解系统性能指标</li>
<li>（3）工作评估：工作量分解，评估工作量，计划资源投入（人，工作日）</li>
<li>（4）设计模型：把业务模型映射成测试模型 ,当需要交互的另一方系统不存在时，自己开发挡板程序（mock程序）进行替代所需功能测试，保证性能测试工作正常进展，这个过程叫设计测试模型</li>
<li>（5）计划编写：在文档中明确列出测试范围，人力投入，持续时间，工作内容，风险评估，风险应对策略等</li>
<li>（6）脚本开发：录制或者编写性能测试脚本</li>
<li>（7）测试环境准备：服务器和负载机两部分，服务器是被测系统的运行平台，负载机是我们用来产生负载的机器，用来安装负载工具，运行测试脚本。</li>
<li>（8）测试数据准备：根据数据模型来准备被测系统的主数据（保证业务能够运行通常的基础）和业务数据，准备存量/历史数据（数据量变引起性能变化）</li>
<li>（9）测试执行：性能测试成败关键，同样脚本不同测试人员测出结果差异大（体现在场景设计与测试执行上）</li>
<li>（10）性能调优：测试人员和开发人员一起解决性能问题</li>
<li>（11）测试报告：性能指标说明（TPS,RT,CPU ,Using），发现的问题性能测试主要交付件：测试计划，测试脚本，测试程序，测试报告或阶段性报告（项目周期长）<h2 id="性能测试的类型"><a href="#性能测试的类型" class="headerlink" title="性能测试的类型"></a>性能测试的类型</h2></li>
<li><strong>基准测试：</strong>在给系统施加较低压力时，查看系统的运行状况并记录相关数做为基础参考</li>
<li><strong>负载测试：</strong>是指对系统不断地增加压力或增加一定压力下的持续时间，直到系统的某项或多项性能指标达到安全临界值，例如某种资源已经达到饱和状态等 。</li>
<li><strong>压力测试：</strong>压力测试是评估系统处于或超过预期负载时系统的运行情况，关注点在于系统在峰值负载或超出最大载荷情况下的处理能力。</li>
<li><strong>稳定性测试：</strong>在给系统加载一定业务压力的情况下，使系统运行一段时间，以此检测系统是否稳定。</li>
<li><strong>并发测试：</strong>测试多个用户同时访问同一个应用、同一个模块或者数据记录时是否存在死锁或者其他性能问题，<h2 id="如何测试一个搜索框"><a href="#如何测试一个搜索框" class="headerlink" title="如何测试一个搜索框"></a>如何测试一个搜索框</h2>测试搜索框，需从以下几个方面进行考虑：</li>
</ul>
<h3 id="一、功能实现"><a href="#一、功能实现" class="headerlink" title="一、功能实现"></a>一、功能实现</h3><p>输入字符，有匹配的就展示出来，没有匹配的，会进行处理</p>
<h4 id="1-对输入进行测试"><a href="#1-对输入进行测试" class="headerlink" title="1.对输入进行测试"></a>1.对输入进行测试</h4><p>正常输入存在的内容，查看搜索结果展示的数据是否完整</p>
<p>正常输入不存在的内容，查看搜索返回的结果</p>
<p>输入为空</p>
<p>超长输入</p>
<p>特殊符号，包含空格，特别要注意英文单引号</p>
<p>各种字符，如数字、字母、中文</p>
<p>反复输入相同的数据，如5次以上，看处理是否正确</p>
<p>输入正则表达式</p>
<p>验证搜索框的功能是否与需求一致，如模糊搜索或完全搜索</p>
<p>是否有忽略空格的功能，忽略前置空格和忽略后置空格，但是不能忽略中间空格</p>
<h4 id="2-快捷键"><a href="#2-快捷键" class="headerlink" title="2.快捷键"></a>2.快捷键</h4><p>在输入结束后，按回车键，看系统如何处理<br>使用Tab键</p>
<pre><code>ctrl+c /v/xz
</code></pre><h4 id="3-光标和鼠标"><a href="#3-光标和鼠标" class="headerlink" title="3.光标和鼠标"></a>3.光标和鼠标</h4><p>   在光标停留的地方进行输入，看光标和输入的字符位置是否正确，会否跳转到别的地方<br>在输入框中，左键单击鼠标，双击鼠标，三击鼠标，如百度输入框，单击是插入，双击选中两个字符，三击选中输入的所有字符<br>输入框中，鼠标右键，会否有菜单栏，菜单栏下是否有常用的项，并且各项可用</p>
<h4 id="4-其它功能"><a href="#4-其它功能" class="headerlink" title="4.其它功能"></a>4.其它功能</h4><p>如百度的即搜即得，随着用户的输入，下面会列出好多实时变化的选项，类似于智能搜索</p>
<h3 id="二、用户友好与易用性"><a href="#二、用户友好与易用性" class="headerlink" title="二、用户友好与易用性"></a>二、用户友好与易用性</h3><h3 id="三、不同平台的兼容性"><a href="#三、不同平台的兼容性" class="headerlink" title="三、不同平台的兼容性"></a>三、不同平台的兼容性</h3><p>浏览器，操作系统，分辨率</p>
<h2 id="如何测试一个网页登陆界面"><a href="#如何测试一个网页登陆界面" class="headerlink" title="如何测试一个网页登陆界面"></a>如何测试一个网页登陆界面</h2><p>　<strong>请你记住一点，任何测试，不管测什么都是从了解需求开始的。</strong></p>
<h3 id="功能测试-Function-test"><a href="#功能测试-Function-test" class="headerlink" title="功能测试(Function test)"></a>功能测试(Function test)</h3><pre><code>  0.什么都不输入，点击提交按钮，看提示信息。
  1.输入正确的用户名和密码，点击提交按钮，验证是否能正确登录。
  2.输入错误的用户名或者密码, 验证登录会失败，并且提示相应的错误信息。
  3.登录成功后能否能否跳转到正确的页面
  4.用户名和密码，如果太短或者太长，应该怎么处理
  5.用户名和密码，中有特殊字符（比如空格），和其他非英文的情况
  6.记住用户名的功能
  7.登陆失败后，不能记录密码的功能
  8.用户名和密码前后有空格的处理
  9.密码是否加密显示（星号圆点等）
  10.牵扯到验证码的，还要考虑文字是否扭曲过度导致辨认难度大，考虑颜色（色盲使用者），刷新或换一个按钮是否好用
  11.登录页面中的注册、忘记密码，登出用另一帐号登陆等链接是否正确
  12.输入密码的时候，大写键盘开启的时候要有提示信息。
</code></pre><h3 id="界面测试-UI-Test"><a href="#界面测试-UI-Test" class="headerlink" title="界面测试(UI Test)"></a>界面测试(UI Test)</h3><pre><code>1.布局是否合理，2个testbox 和一个按钮是否对齐
2.testbox和按钮的长度，高度是否复合要求
3. 界面的设计风格是否与UI的设计风格统一
4. 界面中的文字简洁易懂，没有错别字。
</code></pre><h3 id="性能测试-performance-test"><a href="#性能测试-performance-test" class="headerlink" title="性能测试(performance test)"></a>性能测试(performance test)</h3><pre><code>1.打开登录页面，需要几秒
2.输入正确的用户名和密码后，登录成功跳转到新页面，不超过5秒
安全性测试(Security test)
1.登录成功后生成的Cookie，是否是httponly (否则容易被脚本盗取)
2.用户名和密码是否通过加密的方式，发送给Web服务器
3.用户名和密码的验证，应该是用服务器端验证， 而不能单单是在客户端用javascript验证
4.用户名和密码的输入框，应该屏蔽SQL 注入攻击
5.用户名和密码的的输入框，应该禁止输入脚本 （防止XSS攻击）
6.错误登陆的次数限制（防止暴力破解）
7. 考虑是否支持多用户在同一机器上登录；
8. 考虑一用户在多台机器上登录
</code></pre><h3 id="可用性测试-Usability-Test"><a href="#可用性测试-Usability-Test" class="headerlink" title="可用性测试(Usability Test)"></a>可用性测试(Usability Test)</h3><pre><code>1. 是否可以全用键盘操作，是否有快捷键
2. 输入用户名，密码后按回车，是否可以登陆
3. 输入框能否可以以Tab键切换
</code></pre><h3 id="兼容性测试（Compatibility-Test）"><a href="#兼容性测试（Compatibility-Test）" class="headerlink" title="兼容性测试（Compatibility Test）"></a>兼容性测试（Compatibility Test）</h3><pre><code>1.主流的浏览器下能否显示正常已经功能正常（IE,6,7,8,9, Firefox, Chrome, Safari,等）
2.不同的平台是否能正常工作，比如Windows, Mac
3.移动设备上是否正常工作，比如Iphone, Andriod
4.不同的分辨率
</code></pre><h3 id="本地化测试-（Localization-test）"><a href="#本地化测试-（Localization-test）" class="headerlink" title="本地化测试 （Localization test）"></a>本地化测试 （Localization test）</h3><p>　    　1. 不同语言环境下，页面的显示是否正确。</p>
<h3 id="软件辅助性测试-（Accessibility-test）"><a href="#软件辅助性测试-（Accessibility-test）" class="headerlink" title="软件辅助性测试 （Accessibility test）"></a>软件辅助性测试 （Accessibility test）</h3><p>　　软件辅助功能测试是指测试软件是否向残疾用户提供足够的辅助功能</p>
<ul>
<li>高对比度下能否显示正常 （视力不好的人使用）</li>
</ul>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 valine -->
<div id="comment">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
    new Valine({
        el: '#comment' ,
        notify: true,
        verify: true,
        app_id: 'kz3wsPKNVn8aU9uOSYxwpyPt-gzGzoHsz',
        app_key: 'z7FfKotHzOxCP8I8grnMlOAM',
        placeholder: 'Please leave your footprints',
        pageSize: '10',
        avatar: '',
        avatar_cdn: 'https://gravatar.loli.net/avatar/'
    });
</script>
</div>
<style>
   #comment{
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="https://github.com/donghuixin " style="border-bottom: none;">HuiXin</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
