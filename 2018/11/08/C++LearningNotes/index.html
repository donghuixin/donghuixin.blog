<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.8.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo.ico">
	<link rel="shortcut icon" href="/img/logo.ico">
	
			    <title>
    HuiXinsNote
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    <meta name="keywords" content="PoetryScience">
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_dark.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">PoetryScience</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/iRobots/">iRobots</a></li><li><a class="category-link" href="/categories/写作/">写作</a></li><li><a class="category-link" href="/categories/学习笔记/">学习笔记</a></li><li><a class="category-link" href="/categories/技术笔记/">技术笔记</a></li><li><a class="category-link" href="/categories/文献阅读/">文献阅读</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="好友">
		                好友
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/donghuixin" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="weibo" href="https://weibo.com/u/5315885243?refer_flag=1001030102_&is_hot=1" target="_blank" rel="noopener">
                            <i class="icon fa fa-weibo"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="instagram" href="https://instagram.com/huixindx" target="_blank" rel="noopener">
                            <i class="icon fa fa-instagram"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(https://techtalk.vn/wp-content/uploads/2018/03/maxresdefault-1.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>[Coding]C++学习笔记Day_01</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p>声明：所有学习资料内容均来自WWW.RUNOOB.COM.笔记整理方便查阅复习增强记忆。出处<a href="http://www.runoob.com/cplusplus/cpp-classes-objects.html" target="_blank" rel="noopener">网址链接</a>  <strong>侵删</strong></p>
<h2 id="抽象和分类"><a href="#抽象和分类" class="headerlink" title="抽象和分类"></a>抽象和分类</h2><pre><code>分类所依据的原则--抽象
抽象出同一类对象的共同属性和行为--类
</code></pre><p> 类与对象的关系： 类型与实例的关系等价为模具与铸件之间的关系<br><br> <strong>类的定义</strong></p>
<pre><code>#include &quot;pch.h&quot;
//#include &quot;stdafx.h&quot;
#include &lt;iostream&gt;
using namespace std;//命名空间std内定义的所有标识符都有效（曝光）
class Box
{
public:
    double length;   // 长度
    double breadth;  // 宽度
    double height;   // 高度
};
int main()
{
    Box Box1;        // 声明 Box1，类型为 Box
    Box Box2;        // 声明 Box2，类型为 Box
    double volume = 0.0;     // 用于存储体积
    // box 1 参数
    Box1.height = 5.0;
    Box1.length = 6.0;
    Box1.breadth = 7.0;
    // box 2 参数
    Box2.height = 10.0;
    Box2.length = 12.0;
    Box2.breadth = 13.0;
    // box 1 的体积
    volume = Box1.height * Box1.length * Box1.breadth;
    cout &lt;&lt; &quot;Box1 的体积：&quot; &lt;&lt; volume &lt;&lt; endl;
    // box 2 的体积
    volume = Box2.height * Box2.length * Box2.breadth;
    cout &lt;&lt; &quot;Box2 的体积：&quot; &lt;&lt; volume &lt;&lt; endl;
    return 0;
}
</code></pre><p> <strong>输出结果</strong></p>
<pre><code>  Box1 的体积：210
  Box2 的体积：1560
</code></pre><p>其中 <a href="https://blog.csdn.net/Bruce_0712/article/details/72824668" target="_blank" rel="noopener">using namespace std</a> :命名空间std内定义的所有标识符都有效（曝光）.</p>
<h3 id="类成员函数"><a href="#类成员函数" class="headerlink" title="类成员函数"></a>类成员函数</h3><p>类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员。<br></p>
<pre><code>// 成员函数定义 (同函数的声明和定义)
double Box::getVolume(void)
{
    return length * breadth * height;
}
void Box::setLength( double len )
{
    length = len;
}
void Box::setBreadth( double bre )
{
    breadth = bre;
}
void Box::setHeight( double hei )
{
    height = hei;
}
//成员函数使用（在main函数中使用）
 Box1.setLength(6.0); 
 Box1.setBreadth(7.0); 
 Box1.setHeight(5.0);
 // box 2 
 Box2.setLength(12.0); 
 Box2.setBreadth(13.0); 
 Box2.setHeight(10.0);
 // box 1 的体积
 volume = Box1.getVolume();
 cout &lt;&lt; &quot;Box1 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;
 // box 2 的体积
 volume = Box2.getVolume();
 cout &lt;&lt; &quot;Box2 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;
</code></pre><h3 id="类访问修饰符"><a href="#类访问修饰符" class="headerlink" title="类访问修饰符"></a>类访问修饰符</h3><p>数据封装是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员。类成员的访问限制是通过在类主体内部对各个区域标记 public、private、protected 来指定的。关键字 public、private、protected 称为访问修饰符。<br><br>一个类可以有多个 public、protected 或 private 标记区域。每个标记区域在下一个标记区域开始之前或者在遇到类主体结束右括号之前都是有效的。成员和类的默认访问修饰符是 private。</p>
<h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><p>公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值.</p>
<pre><code>以设置对象的参数为例：
line.length = 10.0; // OK: 因为 length 是公有的
</code></pre><h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p>私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。<strong>只有类和友元函数可以访问私有成员。</strong>默认情况下，类的所有成员都是私有的。例如在下面的类中，width 是一个私有成员，这意味着，如果您没有使用任何访问修饰符，类的成员将被假定为私有成员。</p>
<pre><code>以设置对象的参数为例：
 // box.width = 10.0; // Error: 因为 width 是私有的
 box.setWidth(10.0);  // 使用成员函数设置宽度
</code></pre><h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><p>保护成员变量或函数与私有成员十分相似，但有一点不同，<strong>保护成员在派生类（即子类）中是可访问的</strong>。<br>    example:</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
class Box
{
   protected:
      double width;
};
class SmallBox:Box // SmallBox 是派生类
{
   public:
      void setSmallWidth( double wid );
      double getSmallWidth( void );
};
// 子类的成员函数
double SmallBox::getSmallWidth(void)
{
    return width ;
}
void SmallBox::setSmallWidth( double wid )
{
    width = wid;
}
// 程序的主函数
int main( )
{
   SmallBox box;
   // 使用成员函数设置宽度
   box.setSmallWidth(5.0);
   cout &lt;&lt; &quot;Width of box : &quot;&lt;&lt; box.getSmallWidth() &lt;&lt; endl;
   return 0;
}
</code></pre><h3 id="类的构造函数-amp-析构函数"><a href="#类的构造函数-amp-析构函数" class="headerlink" title="类的构造函数&amp;析构函数"></a>类的构造函数&amp;析构函数</h3><h4 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h4><p>类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。<br>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。<br><br><strong>默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值</strong></p>
<h4 id="类的析构函数"><a href="#类的析构函数" class="headerlink" title="类的析构函数"></a>类的析构函数</h4><p>类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。<br>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。<br>下面的实例有助于更好地理解析构函数的概念：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
class Line
{
   public:
      void setLength( double len );
      double getLength( void );
      Line();   // 这是构造函数声明
      Line(double len);  // 这是带参数的构造函数
      ~Line();  // 这是析构函数声明
   private:
      double length;
};
// 成员函数定义，包括构造函数
Line::Line(void)
{
    cout &lt;&lt; &quot;Object is being created&quot; &lt;&lt; endl;
}
Line::~Line(void)
{
    cout &lt;&lt; &quot;Object is being deleted&quot; &lt;&lt; endl;
}

void Line::setLength( double len )
{
    length = len;
}
double Line::getLength( void )
{
    return length;
}
// 程序的主函数
int main( )
{
   Line line;
   // 设置长度
   line.setLength(6.0); 
   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.getLength() &lt;&lt;endl;
   return 0;
}
</code></pre><p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<pre><code>Object is being created
Length of line : 6
Object is being deleted
</code></pre><h4 id="使用初始化列表来初始化字段："><a href="#使用初始化列表来初始化字段：" class="headerlink" title="使用初始化列表来初始化字段："></a>使用初始化列表来初始化字段：</h4><pre><code>Line::Line( double len): length(len)
{
    cout &lt;&lt; &quot;Object is being created, length = &quot; &lt;&lt; len &lt;&lt; endl;
}
</code></pre><p>上面的语法等同于如下语法：</p>
<pre><code>Line::Line( double len)
{
    length = len;
    cout &lt;&lt; &quot;Object is being created, length = &quot; &lt;&lt; len &lt;&lt; endl;
}
</code></pre><h4 id="注意初始化顺序"><a href="#注意初始化顺序" class="headerlink" title="注意初始化顺序"></a>注意初始化顺序</h4><p><strong>C++ 初始化类成员时，是按照声明的顺序初始化的，而不是按照出现在初始化列表中的顺序。</strong></p>
<pre><code> Student1(int i):b(i),a(b){ }    //异常顺序：发现a的值为0  b的值为2  说明初始化仅仅对b有效果，对a没有起到初始化作用 
//Student1(int i):a(i),b(a){ } //正常顺序：发现a = b = 2 说明两个变量都是初始化了的  
main函数：
Student1 A(2);        //进入默认构造函数 
Student2 B(A);        //进入拷贝构造函数 
A.fprint();            //输出前面初始化的结果 
</code></pre><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：</p>
<pre><code>通过使用另一个同类型的对象来初始化新创建的对象。
复制对象把它作为参数传递给函数。
复制对象，并从函数返回这个对象。
</code></pre><p>如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。拷贝构造函数的最常见形式如下：</p>
<pre><code>classname (const classname &amp;obj) {
   // 构造函数的主体
}
</code></pre><h4 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h4><p>在C++中，下面三种对象需要调用拷贝构造函数！</p>
<pre><code>（1）一个对象以值传递的方式传入函数体
（2）一个对象以值传递的方式从函数返回
（3）一个对象需要通过另外一个对象进行初始化
</code></pre><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。<br>友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。<br>如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend，如下所示：</p>
<pre><code>class Box
{
   double width;
public:
   double length;
   friend void printWidth( Box box );
   void setWidth( double wid );
};
</code></pre><h4 id="友元函数的使用"><a href="#友元函数的使用" class="headerlink" title="友元函数的使用"></a>友元函数的使用</h4><p>因为友元函数没有this指针，则参数要有三种情况： </p>
<pre><code>要访问非static成员时，需要对象做参数；
要访问static成员或全局变量时，则不需要对象做参数；
如果做参数的对象是全局对象，则不需要对象做参数.
可以直接调用友元函数，不需要通过对象或指针
</code></pre><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>C++ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。<br>对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。<br>如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。<br>下面是一个实例，使用内联函数来返回两个数中的最大值：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
inline int Max(int x, int y)
{
   return (x &gt; y)? x : y;
}
// 程序的主函数
int main( )
{
   cout &lt;&lt; &quot;Max (20,10): &quot; &lt;&lt; Max(20,10) &lt;&lt; endl;
   cout &lt;&lt; &quot;Max (0,200): &quot; &lt;&lt; Max(0,200) &lt;&lt; endl;
   cout &lt;&lt; &quot;Max (100,1010): &quot; &lt;&lt; Max(100,1010) &lt;&lt; endl;
   return 0;
}
</code></pre><p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<pre><code>Max (20,10): 20
Max (0,200): 200
Max (100,1010): 1010
</code></pre><h4 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h4><p>只有当函数只有 10 行甚至更少时才将其定义为内联函数.</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h4><p>当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.<br>优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h4><p>滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论:"></a>结论:</h4><p>一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!</p>
<h4 id="另一个实用的经验准则"><a href="#另一个实用的经验准则" class="headerlink" title="另一个实用的经验准则:"></a>另一个实用的经验准则:</h4><p>内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行).<br>有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.</p>
<h3 id="This指针"><a href="#This指针" class="headerlink" title="This指针"></a>This指针</h3><p>在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。<br><br><strong>友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。</strong><br><br>C++ Primer Page 258<br>引入 this：当我们调用成员函数时，实际上是替某个对象调用它。<br><br>成员函数通过一个名为 this 的额外隐式参数来访问调用它的那个对象，当我们调用一个成员函数时，用请求该函数的对象地址初始化 this。例如，如果调用 total.isbn()则编译器负责把 total 的地址传递给 isbn 的隐式形参 this，可以等价地认为编译器将该调用重写成了以下形式：</p>
<pre><code>//伪代码，用于说明调用成员函数的实际执行过程
Sales_data::isbn(&amp;total)
</code></pre><p>其中，调用 Sales_data 的 isbn 成员时传入了 total 的地址。<br><br>在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无须通过成员访问运算符来做到这一点，因为 this 所指的正是这个对象。任何对类成员的直接访问都被看作是对 this 的隐式引用，也就是说，当 isbn 使用 bookNo 时，它隐式地使用 this 指向的成员，就像我们书写了 this-&gt;bookNo 一样。<br><br>对于我们来说，this 形参是隐式定义的。实际上，任何自定义名为 this 的参数或变量的行为都是非法的。我们可以在成员函数体内部使用 this，因此尽管没有必要，我们还是能把 isbn 定义成如下形式：</p>
<pre><code>std::string isbn() const { return this-&gt;bookNo; }
</code></pre><p>因为 this 的目的总是指向“这个”对象，所以 this 是一个常量指针（参见2.4.2节，第56页），我们不允许改变 this 中保存的地址。</p>
<h3 id="指向类的指针"><a href="#指向类的指针" class="headerlink" title="指向类的指针"></a>指向类的指针</h3><p>一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 -&gt;，就像访问指向结构的指针一样。与所有的指针一样，您必须在使用指针之前，对指针进行初始化。<br><a href="http://www.runoob.com/cplusplus/cpp-pointer-to-class.html" target="_blank" rel="noopener">Example</a></p>
<h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><p>可以使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。<br>静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化，如下面的实例所示。</p>
<h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><p>如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问。<br>静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。<br>静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。<br>静态成员函数与普通成员函数的区别：</p>
<pre><code>静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。
普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。
</code></pre><h4 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h4><p>静态成员变量在类中仅仅是声明，没有定义，所以要在类的外面定义，实际上是给静态成员变量分配内存。如果不加定义就会报错，初始化是赋一个初始值，而定义是分配内存。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><pre><code>隐蔽对象的内部细节
对外形成一个边界
只保留有线的对外接口
使用方便、安全性好
</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。<br>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。<br>继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。</p>
<pre><code>意义在于软件复用
改造、扩展已有类形成新的类
</code></pre><p> public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。</p>
<pre><code>1.public 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private
2.protected 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private
3.private 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private
</code></pre><p>但无论哪种继承方式，上面两点都没有改变：</p>
<pre><code>1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；
2.protected 成员可以被派生类访问。
</code></pre><h3 id="基类-amp-派生类"><a href="#基类-amp-派生类" class="headerlink" title="基类 &amp; 派生类"></a>基类 &amp; 派生类</h3><p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p>
<pre><code>class derived-class: access-specifier base-class
</code></pre><p>其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。<br>假设有一个基类 Shape，Rectangle 是它的派生类，如下所示：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
// 基类
class Shape 
{
   public:
      void setWidth(int w)
      {
         width = w;
      }
      void setHeight(int h)
      {
         height = h;
      }
   protected:
      int width;
      int height;
};

// 派生类
class Rectangle: public Shape
{
   public:
      int getArea()
      { 
         return (width * height); 
      }
};

int main(void)
{
   Rectangle Rect;
   Rect.setWidth(5);
   Rect.setHeight(7);
   // 输出对象的面积
   cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;
   return 0;
}
</code></pre><p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<pre><code>Total area: 35
</code></pre><h3 id="类型继承point"><a href="#类型继承point" class="headerlink" title="类型继承point"></a>类型继承point</h3><pre><code>protected成员不能在类外访问
private成员不能在类外访问
基类的public成员，在派生类中变成了protected，可以被派生类访问
基类的protected成员，在派生类中还是protected，可以被派生类访问
基类的private成员不能被派生类访问
基类的protected成员，在派生类中变成了private,可以被派生类访问
基类public成员,在派生类中变成了private,可以被派生类访问
在类里面不写是什么类型，默认是 private 的
如果继承时不显示声明是 private，protected，public 继承，则默认是 private 继承，在 struct 中默认 public 继承
</code></pre><table>
<thead>
<tr>
<th>继承方式</th>
<th>基类的public成员</th>
<th>类的protected成员</th>
<th>基类的private成员</th>
<th>继承引起的访问控制关系变化概括</th>
</tr>
</thead>
<tbody>
<tr>
<td>public继承</td>
<td>仍为public成员</td>
<td>仍为protected成员</td>
<td>不可见</td>
<td>基类的非私有长远在子类的访问属性不变</td>
</tr>
<tr>
<td>protected继承</td>
<td>变为protected成员</td>
<td>变为protected成员</td>
<td>不可见</td>
<td>基类的非私有成员都为子类的保护成员</td>
</tr>
<tr>
<td>rivate继承</td>
<td>变为private成员</td>
<td>变为private成员</td>
<td>不可见</td>
<td>基类中的非私有成员都称为子类的私有成员</td>
</tr>
</tbody>
</table>
<h4 id="Public-继承"><a href="#Public-继承" class="headerlink" title="Public 继承"></a>Public 继承</h4><pre><code>#include&lt;iostream&gt;
#include&lt;assert.h&gt;
using namespace std;
class A{
public:
  int a;
  A(){
    a1 = 1;
    a2 = 2;
    a3 = 3;
    a = 4;
  }
  void fun(){
    cout &lt;&lt; a &lt;&lt; endl;    //正确
    cout &lt;&lt; a1 &lt;&lt; endl;   //正确
    cout &lt;&lt; a2 &lt;&lt; endl;   //正确
    cout &lt;&lt; a3 &lt;&lt; endl;   //正确
  }
public:
  int a1;
protected:
  int a2;
private:
  int a3;
};
class B : public A{
public:
  int a;
  B(int i){
    A();
    a = i;
  }
  void fun(){
    cout &lt;&lt; a &lt;&lt; endl;       //正确，public成员
    cout &lt;&lt; a1 &lt;&lt; endl;       //正确，基类的public成员，在派生类中仍是public成员。
    cout &lt;&lt; a2 &lt;&lt; endl;       //正确，基类的protected成员，在派生类中仍是protected可以被派生类访问。
    cout &lt;&lt; a3 &lt;&lt; endl;       //错误，基类的private成员不能被派生类访问。
  }
};
int main(){
  B b(10);
  cout &lt;&lt; b.a &lt;&lt; endl;
  cout &lt;&lt; b.a1 &lt;&lt; endl;   //正确
  cout &lt;&lt; b.a2 &lt;&lt; endl;   //错误，类外不能访问protected成员
  cout &lt;&lt; b.a3 &lt;&lt; endl;   //错误，类外不能访问private成员
  system(&quot;pause&quot;);
  return 0;
}
</code></pre><h4 id="Protect-继承"><a href="#Protect-继承" class="headerlink" title="Protect 继承"></a>Protect 继承</h4><pre><code>#include&lt;iostream&gt;
#include&lt;assert.h&gt;
using namespace std;
class A{
public:
  int a;
  A(){
    a1 = 1;
    a2 = 2;
    a3 = 3;
    a = 4;
  }
  void fun(){
    cout &lt;&lt; a &lt;&lt; endl;    //正确
    cout &lt;&lt; a1 &lt;&lt; endl;   //正确
    cout &lt;&lt; a2 &lt;&lt; endl;   //正确
    cout &lt;&lt; a3 &lt;&lt; endl;   //正确
  }
public:
  int a1;
protected:
  int a2;
private:
  int a3;
};
class B : protected A{
public:
  int a;
  B(int i){
    A();
    a = i;
  }
  void fun(){
    cout &lt;&lt; a &lt;&lt; endl;       //正确，public成员。
    cout &lt;&lt; a1 &lt;&lt; endl;       //正确，基类的public成员，在派生类中变成了protected，可以被派生类访问。
    cout &lt;&lt; a2 &lt;&lt; endl;       //正确，基类的protected成员，在派生类中还是protected，可以被派生类访问。
    cout &lt;&lt; a3 &lt;&lt; endl;       //错误，基类的private成员不能被派生类访问。
  }
};
int main(){
  B b(10);
  cout &lt;&lt; b.a &lt;&lt; endl;       //正确。public成员
  cout &lt;&lt; b.a1 &lt;&lt; endl;      //错误，protected成员不能在类外访问。
  cout &lt;&lt; b.a2 &lt;&lt; endl;      //错误，protected成员不能在类外访问。
  cout &lt;&lt; b.a3 &lt;&lt; endl;      //错误，private成员不能在类外访问。
  system(&quot;pause&quot;);
  return 0;
}
</code></pre><h4 id="Private继承"><a href="#Private继承" class="headerlink" title="Private继承"></a>Private继承</h4><pre><code>#include&lt;iostream&gt;
#include&lt;assert.h&gt;
using namespace std;
class A{
public:
  int a;
  A(){
    a1 = 1;
    a2 = 2;
    a3 = 3;
    a = 4;
  }
  void fun(){
    cout &lt;&lt; a &lt;&lt; endl;    //正确
    cout &lt;&lt; a1 &lt;&lt; endl;   //正确
    cout &lt;&lt; a2 &lt;&lt; endl;   //正确
    cout &lt;&lt; a3 &lt;&lt; endl;   //正确
  }
public:
  int a1;
protected:
  int a2;
private:
  int a3;
};
class B : private A{
public:
  int a;
  B(int i){
    A();
    a = i;
  }
  void fun(){
    cout &lt;&lt; a &lt;&lt; endl;       //正确，public成员。
    cout &lt;&lt; a1 &lt;&lt; endl;       //正确，基类public成员,在派生类中变成了private,可以被派生类访问。
    cout &lt;&lt; a2 &lt;&lt; endl;       //正确，基类的protected成员，在派生类中变成了private,可以被派生类访问。
    cout &lt;&lt; a3 &lt;&lt; endl;       //错误，基类的private成员不能被派生类访问。
  }
};
int main(){
  B b(10);
  cout &lt;&lt; b.a &lt;&lt; endl;       //正确。public成员
  cout &lt;&lt; b.a1 &lt;&lt; endl;      //错误，private成员不能在类外访问。
  cout &lt;&lt; b.a2 &lt;&lt; endl;      //错误, private成员不能在类外访问。
  cout &lt;&lt; b.a3 &lt;&lt; endl;      //错误，private成员不能在类外访问。
  system(&quot;pause&quot;);
  return 0;
}
</code></pre><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。<br>C++ 类可以从多个类继承成员，语法如下：</p>
<pre><code>class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…
{
&lt;派生类类体&gt;
};
</code></pre><p>其中，访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
// 基类 Shape
class Shape 
{
   public:
      void setWidth(int w)
      {
         width = w;
      }
      void setHeight(int h)
      {
         height = h;
      }
   protected:
      int width;
      int height;
};
// 基类 PaintCost
class PaintCost 
{
   public:
      int getCost(int area)
      {
         return area * 70;
      }
};
// 派生类
class Rectangle: public Shape, public PaintCost
{
   public:
      int getArea()
      { 
         return (width * height); 
      }
};
int main(void)
{
   Rectangle Rect;
   int area;
   Rect.setWidth(5);
   Rect.setHeight(7);
   area = Rect.getArea();
   // 输出对象的面积
   cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;
   // 输出总花费
   cout &lt;&lt; &quot;Total paint cost: $&quot; &lt;&lt; Rect.getCost(area) &lt;&lt; endl;
   return 0;
}
</code></pre><p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<pre><code>Total area: 35
Total paint cost: $2450
</code></pre><h4 id="More"><a href="#More" class="headerlink" title="More"></a>More</h4><p>另外多继承(环状继承),A-&gt;D, B-&gt;D, C-&gt;(A，B)，例如：</p>
<pre><code>class D{......};
class B: public D{......};
class A: public D{......};
class C: public B, public A{.....};
</code></pre><p>这个继承会使D创建两个对象,要解决上面问题就要用虚拟继承格式</p>
<p>格式：class 类名: virtual 继承方式 父类名</p>
<pre><code>class D{......};
class B: virtual public D{......};
class A: virtual public D{......};
class C: public B, public A{.....};
</code></pre><p>虚继承–（在创建对象的时候会创建一个虚表）在创建父类对象的时候</p>
<pre><code>A:virtual public D
B:virtual public D
</code></pre><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><pre><code>同样的消息作用在不同的对象上有可能引起不同的行为。
</code></pre><p>多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。<br>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。<br>下面的实例中，基类 Shape 被派生为两个类，如下所示：</p>
<pre><code>#include &lt;iostream&gt; 
using namespace std;
class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      int area()
      {
         cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt;endl;
         return 0;
      }
};
class Rectangle: public Shape{
   public:
      Rectangle( int a=0, int b=0):Shape(a, b) { }
      int area ()
      { 
         cout &lt;&lt; &quot;Rectangle class area :&quot; &lt;&lt;endl;
         return (width * height); 
      }
};
class Triangle: public Shape{
   public:
      Triangle( int a=0, int b=0):Shape(a, b) { }
      int area ()
      { 
         cout &lt;&lt; &quot;Triangle class area :&quot; &lt;&lt;endl;
         return (width * height / 2); 
      }
};
// 程序的主函数
int main( )
{
   Shape *shape;
   Rectangle rec(10,7);
   Triangle  tri(10,5);
   // 存储矩形的地址
   shape = &amp;rec;
   // 调用矩形的求面积函数 area
   shape-&gt;area();
   // 存储三角形的地址
   shape = &amp;tri;
   // 调用三角形的求面积函数 area
   shape-&gt;area();
   return 0;
}
</code></pre><p>  当上面的代码被编译和执行时，它会产生下列结果：</p>
<pre><code>Parent class area
Parent class area
</code></pre><p>导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为 area() 函数在程序编译期间就已经设置好了。<br>但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 virtual，如下所示：</p>
<pre><code>class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      virtual int area()
      {
         cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt;endl;
         return 0;
      }
};
</code></pre><p>修改后，当编译和执行前面的实例代码时，它会产生以下结果：</p>
<pre><code>Rectangle class area
Triangle class area
</code></pre><p>此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 $<em>shape $中，所以会调用各自的 area() 函数。<br>正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是多态的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。</em></p>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。<br><br>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。</p>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。<br>我们可以把基类中的虚函数 area() 改写如下：</p>
<pre><code>class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      // pure virtual function
      virtual int area() = 0;
};
</code></pre><p>= 0 告诉编译器，函数没有主体，上面的虚函数是纯虚函数。</p>
<h3 id="TIPS-1"><a href="#TIPS-1" class="headerlink" title="TIPS"></a>TIPS</h3><pre><code>1、纯虚函数声明如下： virtual void funtion1()=0; 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。
2、虚函数声明如下：virtual ReturnType FunctionName(Parameter) 虚函数必须实现，如果不实现，编译器将报错，错误提示为：
error LNK****: unresolved external symbol &quot;public: virtual void __thiscall ClassName::virtualFunctionName(void)&quot;
3、对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。
4、实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。
5、虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。
6、在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。
7、友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。
8、析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。
</code></pre><h2 id="重载运算符和重载函数"><a href="#重载运算符和重载函数" class="headerlink" title="重载运算符和重载函数"></a>重载运算符和重载函数</h2><p>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。<br>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。<br>当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。</p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。<br>下面的实例中，同名函数 print() 被用于输出不同的数据类型：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
class printData
{
   public:
      void print(int i) {
        cout &lt;&lt; &quot;整数为: &quot; &lt;&lt; i &lt;&lt; endl;
      }
      void print(double  f) {
        cout &lt;&lt; &quot;浮点数为: &quot; &lt;&lt; f &lt;&lt; endl;
      }
      void print(char c[]) {
        cout &lt;&lt; &quot;字符串为: &quot; &lt;&lt; c &lt;&lt; endl;
      }
};

int main(void)
{
   printData pd;
   // 输出整数
   pd.print(5);
   // 输出浮点数
   pd.print(500.263);
   // 输出字符串
   char c[] = &quot;Hello C++&quot;;
   pd.print(c);
   return 0;
}
</code></pre><p> 当上面的代码被编译和执行时，它会产生下列结果：</p>
<pre><code>整数为: 5
浮点数为: 500.263
字符串为: Hello C++
</code></pre><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。<br>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。<br><br>Box operator+(const Box&amp;);<br>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：<br><br>Box operator+(const Box&amp;, const Box&amp;);<br>下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 this 运算符进行访问，如下所示:</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
class Box
{
   public:

      double getVolume(void)
      {
         return length * breadth * height;
      }
      void setLength( double len )
      {
          length = len;
      }

      void setBreadth( double bre )
      {
          breadth = bre;
      }

      void setHeight( double hei )
      {
          height = hei;
      }
      // 重载 + 运算符，用于把两个 Box 对象相加
      Box operator+(const Box&amp; b)
      {
         Box box;
         box.length = this-&gt;length + b.length;
         box.breadth = this-&gt;breadth + b.breadth;
         box.height = this-&gt;height + b.height;
         return box;
      }
   private:
      double length;      // 长度
      double breadth;     // 宽度
      double height;      // 高度
};
// 程序的主函数
int main( )
{
   Box Box1;                // 声明 Box1，类型为 Box
   Box Box2;                // 声明 Box2，类型为 Box
   Box Box3;                // 声明 Box3，类型为 Box
   double volume = 0.0;     // 把体积存储在该变量中
   // Box1 详述
   Box1.setLength(6.0); 
   Box1.setBreadth(7.0); 
   Box1.setHeight(5.0);
   // Box2 详述
   Box2.setLength(12.0); 
   Box2.setBreadth(13.0); 
   Box2.setHeight(10.0);
   // Box1 的体积
   volume = Box1.getVolume();
   cout &lt;&lt; &quot;Volume of Box1 : &quot; &lt;&lt; volume &lt;&lt;endl;
   // Box2 的体积
   volume = Box2.getVolume();
   cout &lt;&lt; &quot;Volume of Box2 : &quot; &lt;&lt; volume &lt;&lt;endl;

   // 把两个对象相加，得到 Box3
   Box3 = Box1 + Box2;
   // Box3 的体积
   volume = Box3.getVolume();
   cout &lt;&lt; &quot;Volume of Box3 : &quot; &lt;&lt; volume &lt;&lt;endl;
   return 0;
}
</code></pre><h2 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h2><p>数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。</p>
<p>数据抽象是一种依赖于接口和实现分离的编程（设计）技术。</p>
<p>让我们举一个现实生活中的真实例子，比如一台电视机，您可以打开和关闭、切换频道、调整音量、添加外部组件（如喇叭、录像机、DVD 播放器），但是您不知道它的内部实现细节，也就是说，您并不知道它是如何通过缆线接收信号，如何转换信号，并最终显示在屏幕上。</p>
<p>因此，我们可以说电视把它的内部实现和外部接口分离开了，您无需知道它的内部实现原理，直接通过它的外部接口（比如电源按钮、遥控器、声量控制器）就可以操控电视。</p>
<p>现在，让我们言归正传，就 C++ 编程而言，C++ 类为数据抽象提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。</p>
<p>例如，您的程序可以调用 sort() 函数，而不需要知道函数中排序数据所用到的算法。实际上，函数排序的底层实现会因库的版本不同而有所差异，只要接口不变，函数调用就可以照常工作。</p>
<p>在 C++ 中，我们使用类来定义我们自己的抽象数据类型（ADT）。您可以使用类 iostream 的 cout 对象来输出数据到标准输出，如下所示：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int main( )
{
   cout &lt;&lt; &quot;Hello C++&quot; &lt;&lt;endl;
   return 0;
}
</code></pre><h3 id="访问标签强制抽象"><a href="#访问标签强制抽象" class="headerlink" title="访问标签强制抽象"></a>访问标签强制抽象</h3><p>在 C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签：</p>
<p>使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。<br>使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。<br>访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。</p>
<h3 id="数据抽象的好处"><a href="#数据抽象的好处" class="headerlink" title="数据抽象的好处"></a>数据抽象的好处</h3><p>数据抽象有两个重要的优势：</p>
<p>类的内部受到保护，不会因无意的用户级错误导致对象状态受损。<br>类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。<br>如果只在类的私有部分定义数据成员，编写该类的作者就可以随意更改数据。如果实现发生改变，则只需要检查类的代码，看看这个改变会导致哪些影响。如果数据是公有的，则任何直接访问旧表示形式的数据成员的函数都可能受到影响。</p>
<h3 id="数据抽象的实例"><a href="#数据抽象的实例" class="headerlink" title="数据抽象的实例"></a>数据抽象的实例</h3><pre><code>#include &lt;iostream&gt;
using namespace std;
class Adder{
   public:
      // 构造函数
      Adder(int i = 0)
      {
        total = i;
      }
      // 对外的接口
      void addNum(int number)
      {
          total += number;
      }
      // 对外的接口
      int getTotal()
      {
          return total;
      };
   private:
      // 对外隐藏的数据
      int total;
};
int main( )
{
   Adder a;
   a.addNum(10);
   a.addNum(20);
   a.addNum(30);
   cout &lt;&lt; &quot;Total &quot; &lt;&lt; a.getTotal() &lt;&lt;endl;
   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果： Total 60
</code></pre><h2 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h2><p>所有的 C++ 程序都有以下两个基本要素：</p>
<p>程序语句（代码）：这是程序中执行动作的部分，它们被称为函数。<br>程序数据：数据是程序的信息，会受到程序函数的影响。<br>封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即数据隐藏。</p>
<p>数据封装是一种把数据和操作数据的函数捆绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。</p>
<p>C++ 通过创建类来支持封装和数据隐藏（public、protected、private）。我们已经知道，类包含私有成员（private）、保护成员（protected）和公有成员（public）成员。默认情况下，在类中定义的所有项目都是私有的。例如：</p>
<pre><code>class Box
{
   public:
      double getVolume(void)
      {
         return length * breadth * height;
      }
   private:
      double length;      // 长度
      double breadth;     // 宽度
      double height;      // 高度
};
</code></pre><p>变量 length、breadth 和 height 都是私有的（private）。这意味着它们只能被 Box 类中的其他成员访问，而不能被程序中其他部分访问。这是实现封装的一种方式。</p>
<p>为了使类中的成员变成公有的（即，程序中的其他部分也能访问），必须在这些成员前使用 public 关键字进行声明。所有定义在 public 标识符后边的变量或函数可以被程序中所有其他的函数访问。</p>
<p>把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节。<br>C++ 程序中，任何带有公有和私有成员的类都可以作为数据封装和数据抽象的实例。请看下面的实例：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

class Adder{
   public:
      // 构造函数
      Adder(int i = 0)
      {
        total = i;
      }
      // 对外的接口
      void addNum(int number)
      {
          total += number;
      }
      // 对外的接口
      int getTotal()
      {
          return total;
      };
   private:
      // 对外隐藏的数据
      int total;
};
int main( )
{
   Adder a;

   a.addNum(10);
   a.addNum(20);
   a.addNum(30);

   cout &lt;&lt; &quot;Total &quot; &lt;&lt; a.getTotal() &lt;&lt;endl;
   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：Total 60
</code></pre><p>上面的类把数字相加，并返回总和。公有成员 addNum 和 getTotal 是对外的接口，用户需要知道它们以便使用类。私有成员 total 是对外隐藏的，用户不需要了解它，但它又是类能正常工作所必需的。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口描述了类的行为和功能，而不需要完成类的特定实现。</p>
<p>C++ 接口是使用抽象类来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。</p>
<p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的，如下所示：<br>    class Box<br>    {<br>       public:<br>          // 纯虚函数<br>          virtual double getVolume() = 0;<br>       private:<br>          double length;      // 长度<br>          double breadth;     // 宽度<br>          double height;      // 高度<br>    };<br>设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。</p>
<p>因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。</p>
<p>可用于实例化对象的类被称为具体类。抽象类的实例<br>请看下面的实例，基类 Shape 提供了一个接口 getArea()，在两个派生类 Rectangle 和 Triangle 中分别实现了 getArea()：<br>实例</p>
<pre><code>#include &lt;iostream&gt;

using namespace std;

// 基类
class Shape 
{
public:
   // 提供接口框架的纯虚函数
   virtual int getArea() = 0;
   void setWidth(int w)
   {
      width = w;
   }
   void setHeight(int h)
   {
      height = h;
   }
protected:
   int width;
   int height;
};

// 派生类
class Rectangle: public Shape
{
public:
   int getArea()
   { 
      return (width * height); 
   }
};
class Triangle: public Shape
{
public:
   int getArea()
   { 
      return (width * height)/2; 
   }
};

int main(void)
{
   Rectangle Rect;
   Triangle  Tri;

   Rect.setWidth(5);
   Rect.setHeight(7);
   // 输出对象的面积
   cout &lt;&lt; &quot;Total Rectangle area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;

   Tri.setWidth(5);
   Tri.setHeight(7);
   // 输出对象的面积
   cout &lt;&lt; &quot;Total Triangle area: &quot; &lt;&lt; Tri.getArea() &lt;&lt; endl; 

   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：
Total Rectangle area: 35
Total Triangle area: 17
</code></pre><p>从上面的实例中，我们可以看到一个抽象类是如何定义一个接口 getArea()，两个派生类是如何通过不同的计算面积的算法来实现这个相同的函数。</p>
<hr>
<h2 id="C-程序的开发过程"><a href="#C-程序的开发过程" class="headerlink" title="C++程序的开发过程"></a>C++程序的开发过程</h2><pre><code>算法与数据结构设计
源程序编辑
编译
连接
调试
</code></pre>
            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'https://poetryscience.ink/2018/11/08/C++LearningNotes/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'https://poetryscience.ink/2018/11/08/C++LearningNotes/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
